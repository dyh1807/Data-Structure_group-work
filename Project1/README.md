# 马踏棋盘（骑士周游问题）

## 简述

给定一个$8\times 8$ 的棋盘，指定一个初始位置，要求给出从初始位置不重复的遍历所有棋盘格的马字走法。

## 基本需求

需要编写一个非递归程序，求出行走路线(1条)，填入方格作为输出。

## 进阶需求

1. 求出全部行走路线
2. 讨论每次选择的“最佳策略”。所谓“最佳”，指的是使得回溯次数最少的选择方法。
3. 演示回溯过程。

## 分析

### 基本需求的实现

可以用$8\times 8$ 的数组帮助实现棋盘，数组某个位置的值为0表示还没有走过，为k则表示这时第k步走的位置；栈帮助实现类似递归的效果。

首先将1入栈，表示起始位置已经完成了占位。之后如果有没有尝试过的下一步，就入栈；如果所有的下一步位置都已经遍历过了，就弹栈。这一过程用递归可以很方便的实现，使用栈是为了模拟这个递归的过程。

递归版本的的文件已经在Project1/recursion-version/recursion.cpp 中实现了，采用的是dfs搜索。由于全部的马踏棋盘方法至少有数十万种，并且递归的dfs算法速度很慢，所以只打印了搜索到的10种方法。

### 全部行走路线的实现

其实基本需求的实现种已经实现了求多条路的办法，只是速度并不快。

因为实际上这是一个NP完全问题的元素，所以应该没有很好的解决算法。实际上，对$6\times 6$ 的棋盘，成功遍历的方式就有524486种，需要笔记本电脑计算2个小时才得到全部遍历方式。所以，我们的设计里只要考虑“多条路”就可以了，不用真正打印出全部的输出结果。

### 最佳策略

也就是采用贪心算法选择下一次走路的选择。这个选法有待参考网上的一些资料，大概的意思是“先苦后甜”，每一次都选择下一步可走路线尽可能少的格子，这样走到最后时可走的格子的选择就可以尽可能多了。

### 回溯过程的演示

不难实现，只要在每一次回溯后立刻打印一次回溯后的结果就可以了。

## 文件说明

在Project1/目录下，Recursion/子目录中的cpp程序用作参考。main.cpp为主函数文件，TraverseBoard.h为使用的函数、数据结构的头文件。
